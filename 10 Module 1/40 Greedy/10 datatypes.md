# Datatypes

Python kent verschillende datatypes om mee te werken. `string`s, `float`s en `int`s heb je al voorbij zien komen. Zo zijn `string`s sequenties aan tekens, `int`s gehele getalen en `float`s komma getallen. Afhankelijk van het datatype waar je mee werkt, kun je verschillende operaties doen. Zo evalueert `3 * 5` naar `15` en `"vijf" * 5` naar `"vijfvijfvijfvijfvijf"`. Zo geeft `9 - 4` als antwoord `5`, maar leidt `"negen" - 4` tot een error! Niet elke operatie kan dus met alle verschillende datatypes omgaan, en afhankelijk van de datastructuur komt er een ander resultaat uit. 

Kijken we naar de interactie tussen `int`s en `float`s dan zien we iets eigenaardigs. Zo is `3 * 5` nog steeds `15`, maar is `3 * 5.0` ineens `15.0`. Ook is `1 / 2` gelijk aan `0` en `1 / 2.0` gelijk aan `0.5`. Python maakt namelijk van de uitkomst van een berekening waar zowel een `int` als een `float` in voorkomen automatisch een `float`. Vaak is dit ook wat je wilt, maar niet altijd.

Kommagetallen zijn namelijk lastig te representeren. Zou je bijvoorbeeld in ons decimaal stelsel het resultaat van `1/3` uitschrijven dan krijg je `0.3333...` tot in de oneindigheid. Hoe langer we doorgaan met het schrijven van 3-en, hoe preciezer de uitkomst van `1/3`, maar we kunnen het nooit precies opschrijven. In de binaire wereld van 0-en, en 1-en komt hetzelfde probleem voor, maar dan bij `1/10`. Dit betekent dat er ergens een compromis gesloten moet worden, en we noodgedwongen een klein afrondingsfoutje maken als we rekenen met `float`s. Probeer maar eens de volgende regel uit: `print "%.100f" % (1.0 / 10)`. Deze regel forceert Python om 100 cijfers achter de komma uit te printen. Mocht je geen afrondingsfouten willen, dan moet je dus uitwijken naar een ander datatype zoals bijvoorbeeld `int`. 